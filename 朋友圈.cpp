//https://leetcode-cn.com/explore/interview/card/bytedance/243/array-and-sorting/1036/
//班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。
//给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。
//仍然使用等价类，属于同一类的朋友都在一棵树下面
#include <iostream>
#include <vector>
using namespace std;
	//结果要么是返回自己，要么是返回祖先中最高的辈分 
    int find1(int i,int p[]){
		while(p[i]!=i){
            i=p[i];
        }
        return i;
    }
    //找到i的根节点，让j的父亲变为这个节点 
    void union1(int i,int j,int p[]){
    	if(i!=j){
    		p[i]=j;
		} 
    }
    int findCircleNum(vector<vector<int>>& M) {
        int n=M.size();
        int p[n];
        int count[n];
        for(int i=0;i<n;i++){
            p[i]=i;
            count[i]=0;
        }
        
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                if(M[i][j]==1){
                    //我在这个地方bug了很久，一定要合并根节点所在的树，即找到父节点然后合并，否则会出现bug
                    union1(find1(i,p),find1(j,p),p);
                }
            }
        }
        
        for(int i=0;i<n;i++){
            int a=find1(i,p);
            //cout<<a;
            count[a]=count[a]+1;
            //cout<<count[a]<<' '<<a<<endl;            
        }
        //cout<<"here"; 
        int c=0;
        for(int i=0;i<n;i++){
        	//cout<<count[i];
            if(count[i]>0){
                c=c+1;
            }
        }
        return c;
    }
    int main(){
    	vector<vector<int>> a={{1,1,0,0,0,0,0,1,0,0,0,0,0,0,0},{1,1,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,1,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,0,1,1,0,0,0,0,0,0,0,0},{0,0,0,0,1,0,0,0,0,1,1,0,0,0,0},{0,0,0,1,0,1,0,0,0,0,1,0,0,0,0},{0,0,0,1,0,0,1,0,1,0,0,0,0,1,0},{1,0,0,0,0,0,0,1,1,0,0,0,0,0,0},{0,0,0,0,0,0,1,1,1,0,0,0,0,1,0},{0,0,0,0,1,0,0,0,0,1,0,1,0,0,1},{0,0,0,0,1,1,0,0,0,0,1,1,0,0,0},{0,0,0,0,0,0,0,0,0,1,1,1,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,1,0,0},{0,0,0,0,0,0,1,0,1,0,0,0,0,1,0},{0,0,0,0,0,0,0,0,0,1,0,0,0,0,1}};
		//{{1,1,0},{1,1,0},{0,0,1}};
		//{{1,0,0,1},{0,1,1,0},{0,1,1,1},{1,0,1,1}};//
    	cout<<findCircleNum(a);
	}
